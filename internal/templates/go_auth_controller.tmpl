package auth

import (
	"fmt"
	"os"

	"{{.App.Repository}}/internal/{{.App.Authentication.Entity}}"
	"github.com/gofiber/fiber/v2"
	"github.com/golang-jwt/jwt"
)

type SignInParams struct {
	Email    string `json:"email" bson:"email,omitempty"`
	Password string `json:"password" bson:"-"`
}

type Controller interface {
	SignIn(*fiber.Ctx) error
	SignOut(*fiber.Ctx) error
	Me(*fiber.Ctx) error
}

type controller struct {
	{{.App.Authentication.Entity}}Service {{.App.Authentication.Entity}}.Service
}

func (c *controller) SignIn(ctx *fiber.Ctx) error {
	var params SignInParams
	err := ctx.BodyParser(&params)

	if err != nil {
		return err
	}

	result, err := c.{{.App.Authentication.Entity}}Service.GetOne(&{{.App.Authentication.Entity}}.GetOneParams{
		Email: params.Email,
	})

	if err != nil {
		return err
	}

	if result == nil {
		return fiber.ErrUnauthorized
	}

	if {{.App.Authentication.Entity}}.CheckPassword(params.Password, result.Password) {
		token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
			"email":  result.Email,
			"userId": result.ID,
		})

		secret := []byte(os.Getenv("TOKEN_SECRET"))
		tokenString, err := token.SignedString(secret)

		if err != nil {
			return fmt.Errorf("error generating jwt token")
		}

		return ctx.JSON(map[string]string{
			"authToken": tokenString,
		})
	}

	return fiber.ErrUnauthorized
}

func (c *controller) SignOut(ctx *fiber.Ctx) error {
	return fiber.ErrNotImplemented
}

func (c *controller) Me(ctx *fiber.Ctx) error {
	params := {{.App.Authentication.Entity}}.GetOneParams{
		ID: ctx.Locals("{{.App.Authentication.Entity}}Id").(string),
	}

	{{.App.Authentication.Entity}}, err := c.{{.App.Authentication.Entity}}Service.GetOne(&params)

	if err != nil {
		return err
	}

	if user == nil {
		return fiber.ErrNotFound
	}

	return ctx.JSON({{.App.Authentication.Entity}})
}

func NewController({{.App.Authentication.Entity}}Service {{.App.Authentication.Entity}}.Service) Controller {
	return &controller{userService: {{.App.Authentication.Entity}}Service}
}
